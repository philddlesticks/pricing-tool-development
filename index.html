<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pricing List Processing Tool</title>
    <link rel="stylesheet" href="pricingstyles.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
</head>
<body>
    <div class="container">
        <h1>üìä Pricing List Processing Tool</h1>
        <p class="subtitle">Upload, edit, and compare pricing data with change detection</p>

        <!-- Step 1: Settings -->
        <div id="step1" class="step active">
            <div class="step-header">Step 1: Settings</div>

            <div class="alert alert-info">
                Enter the pricing list details below before uploading your file.
            </div>

            <div style="max-width: 600px; margin: 0 auto;">
                <div class="mapping-item" style="margin-bottom: 20px;">
                    <label>Manufacturer Name (or "Multiple Manufacturers"):</label>
                    <input type="text" id="manufacturerName" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;" placeholder="Enter manufacturer or brand name">
                </div>

                <div class="mapping-item" style="margin-bottom: 20px;">
                    <label>Supplier Account Number:</label>
                    <input type="text" id="supplierAccountNumber" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;" placeholder="Enter supplier account number">
                </div>

                <div class="mapping-item" style="margin-bottom: 20px;">
                    <label>Price List Effective Date:</label>
                    <input type="date" id="effectiveDate" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; cursor: pointer;" onclick="this.showPicker ? this.showPicker() : this.focus();">
                </div>
            </div>

            <div class="button-group">
                <button class="btn" onclick="validateSettings()">Next: Upload File ‚Üí</button>
            </div>
        </div>

        <!-- Step 2: Upload -->
        <div id="step2" class="step">
            <div class="step-header">Step 2: Upload Pricing File</div>
            <div class="upload-area" id="uploadArea">
                <h2>üìÅ Drop file here or click to browse</h2>
                <p style="color: #666; margin-top: 10px;">Supports .xlsx, .xls, and .csv formats</p>
                <input type="file" id="fileInput" accept=".xlsx,.xls,.csv">
            </div>

            <div id="uploadMessages" style="margin: 15px 0;"></div>

            <div class="alert alert-info">
                <strong>Optional:</strong> Upload previous pricing data for comparison
                <input type="file" id="previousFileInput" accept=".xlsx,.xls,.csv,.json" style="display: block; margin-top: 10px;">
            </div>

            <div id="previousUploadMessages" style="margin: 15px 0;"></div>

            <div class="button-group">
                <button class="btn btn-secondary" onclick="goToStep(1)">‚Üê Back to Settings</button>
                <button class="btn" id="uploadNextBtn" onclick="proceedFromUpload()" disabled>Next: Map Columns ‚Üí</button>
            </div>
        </div>
        
        <!-- Step 3: Map Columns -->
        <div id="step3" class="step">
            <div class="step-header">Step 3: Map Columns</div>
            <div class="alert alert-info">
                Assign each column from your uploaded file to the appropriate field using the dropdowns below each column header.
            </div>

            <div style="background: #f8f9fa; padding: 15px; border-radius: 6px; margin-bottom: 20px; border: 2px solid #007bff;">
                <strong>‚ÑπÔ∏è Column Assignment Guide:</strong>
                <div style="margin-top: 10px;">
                    <small style="color: #666;">
                        <strong>Required:</strong> Supplier Part Number + (List Price GBP OR Cost Price)<br>
                        <strong>Optional:</strong> Description, Barcode, Manufacturer, Country of Origin<br><br>
                        <strong>Next Step:</strong> Based on your mapping, Step 3 will automatically provide:<br>
                        ‚Ä¢ Discount % column (if you only have List Price GBP)<br>
                        ‚Ä¢ Markup % column (if you only have Cost Price)<br>
                        ‚Ä¢ Direct editing (if you have both Cost Price and List Price GBP)
                    </small>
                </div>
            </div>

            <div class="spreadsheet-container">
                <table class="spreadsheet" id="mappingTable"></table>
            </div>
            <div class="button-group">
                <button class="btn btn-secondary" onclick="goToStep(2)">‚Üê Back</button>
                <button class="btn" onclick="validateMapping()">Next: Edit Data ‚Üí</button>
            </div>
        </div>

        <!-- Step 4: Edit Data -->
        <div id="step4" class="step">
            <div class="step-header">Step 4: Edit Data</div>
            <div class="alert alert-info" id="step3Info">
                Edit your data and apply discounts or markups as needed.
            </div>

            <div class="discount-tools" id="step3Tools">
                <strong>üí° Quick Pricing Tools:</strong><br><br>

                <div id="discountToolsSection3" style="margin-bottom: 15px; display: none;">
                    <label>üè∑Ô∏è Discount value:</label>
                    <input type="number" id="bulkDiscount3" placeholder="e.g., 20" min="0" max="100" step="0.1">
                    <button class="btn btn-success" onclick="applyDiscountToSelected()">Apply to Selected Rows</button>
                    <button class="btn" onclick="applyBulkDiscount()">Apply to All Rows</button>
                    <button class="btn btn-secondary" onclick="clearSelectedDiscounts()">Clear Selected</button>
                    <button class="btn btn-secondary" onclick="clearAllDiscounts()">Clear All</button>
                </div>

                <div id="markupToolsSection3" style="margin-bottom: 15px; display: none;">
                    <label>üìà Markup value:</label>
                    <input type="number" id="bulkMarkup3" placeholder="e.g., 25" min="0" max="1000" step="0.1">
                    <button class="btn btn-success" onclick="applyMarkupToSelected()">Apply to Selected Rows</button>
                    <button class="btn" onclick="applyBulkMarkup()">Apply to All Rows</button>
                    <button class="btn btn-secondary" onclick="clearSelectedMarkups()">Clear Selected</button>
                    <button class="btn btn-secondary" onclick="clearAllMarkups()">Clear All</button>
                </div>

                <div style="background: white; padding: 10px; border-radius: 4px; border-left: 4px solid #007bff;">
                    <strong>How to use:</strong><br>
                    <small style="color: #666;">
                        1Ô∏è‚É£ <strong>Select rows:</strong> Click row numbers below (hold Ctrl for multiple)<br>
                        2Ô∏è‚É£ <strong>Enter value:</strong> Type percentage in box above<br>
                        3Ô∏è‚É£ <strong>Apply:</strong> Click "Apply to Selected Rows" or "Apply to All Rows"<br><br>
                        <strong>Keyboard shortcuts:</strong><br>
                        ‚Ä¢ Click a cell with a value ‚Üí <strong>Ctrl+C</strong> to copy<br>
                        ‚Ä¢ Select destination rows (Ctrl+click row numbers)<br>
                        ‚Ä¢ Press <strong>Ctrl+Shift+V</strong> to paste to all selected rows
                    </small>
                </div>
            </div>

            <div class="spreadsheet-container">
                <table class="spreadsheet" id="spreadsheet"></table>
            </div>
            <div class="button-group">
                <button class="btn btn-secondary" onclick="goToStep(3)">‚Üê Back to Mapping</button>
                <button class="btn" onclick="goToStep(5)">Next: Review & Process ‚Üí</button>
            </div>
        </div>

        <!-- Step 5: Review & Process -->
        <div id="step5" class="step">
            <div class="step-header">Step 5: Review & Process</div>

            <div class="alert alert-info">
                Review your mapped data below before processing. Make sure all columns are correctly assigned.
            </div>

            <div class="preview-table">
                <h3>Preview Mapped Data (first 10 rows):</h3>
                <table class="comparison-table" id="previewTable"></table>
            </div>

            <div class="button-group">
                <button class="btn btn-secondary" onclick="goToStep(4)">‚Üê Back to Edit</button>
                <button class="btn" onclick="goToStep(6)">Next: Original Price List ‚Üí</button>
            </div>
        </div>

        <!-- Step 6: Original Price List -->
        <div id="step6" class="step">
            <div class="step-header">Step 6: Original Price List</div>

            <div class="alert alert-info">
                Review the original price list data with variant matching. Edit the "Description to use" field if needed.
            </div>

            <div class="spreadsheet-container">
                <table class="comparison-table" id="originalPriceTable"></table>
            </div>

            <div class="button-group">
                <button class="btn btn-secondary" onclick="goToStep(5)">‚Üê Back</button>
                <button class="btn" onclick="processData()">Next: Review Changes ‚Üí</button>
            </div>
        </div>

        <!-- Step 7: Review Results -->
        <div id="step7" class="step">
            <div class="step-header">Step 7: Review Changes & Flagged Items</div>
            
            <div class="stats-grid" id="statsGrid"></div>
            
            <div class="alert alert-warning" id="flaggedAlert" style="display:none;">
                <strong>‚ö†Ô∏è Attention Required:</strong> Items flagged below meet criteria: ‚â•15% increase OR ‚â§-10% decrease with cost ‚â•¬£100
            </div>
            
            <div style="margin: 20px 0;">
                <label style="margin-right: 20px;">
                    <input type="checkbox" id="showOnlyFlagged" onchange="toggleFilter()">
                    Show only flagged items
                </label>
                <label>
                    <input type="checkbox" id="showOnlyNew" onchange="toggleFilter()">
                    Show only new items
                </label>
            </div>
            
            <div class="spreadsheet-container">
                <table class="comparison-table" id="comparisonTable"></table>
            </div>
            
            <div class="button-group">
                <button class="btn btn-secondary" onclick="goToStep(6)">‚Üê Back</button>
                <button class="btn btn-success" onclick="saveData()">üíæ Save to Server</button>
                <button class="btn" onclick="exportJSON()">üì• Export JSON</button>
                <button class="btn" onclick="exportCSV()">üì• Export CSV</button>
            </div>
        </div>
    </div>

    <script>
        let currentData = [];
        let previousData = [];
        let processedData = [];
        let columnMapping = {};
        let currentStep = 1;
        let selectedRows = new Set();
        let copiedValue = null;
        let excludedRows = new Set();
        let descriptionToUseMap = {}; // Store "Description to use" values by product code

        // Settings data
        let settings = {
            manufacturerName: '',
            supplierAccountNumber: '',
            effectiveDate: ''
        };
        
        const REQUIRED_FIELDS = ['code', 'listPrice'];
        const OPTIONAL_FIELDS = ['description', 'barcode', 'costPrice', 'discount'];
        
        // File upload handling
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const previousFileInput = document.getElementById('previousFileInput');
        
        uploadArea.addEventListener('click', () => fileInput.click());
        
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });
        
        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });
        
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file) handleFile(file);
        });
        
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) handleFile(file);
        });
        
        previousFileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) handlePreviousFile(file);
        });
        
        function handleFile(file) {
            const reader = new FileReader();
            const isCSV = file.name.toLowerCase().endsWith('.csv');

            reader.onload = (e) => {
                let jsonData;

                if (isCSV) {
                    // Handle CSV files
                    const text = e.target.result;
                    const lines = text.split('\n').filter(line => line.trim());
                    jsonData = lines.map(line => {
                        // Simple CSV parsing - handles quoted fields
                        const result = [];
                        let current = '';
                        let inQuotes = false;

                        for (let i = 0; i < line.length; i++) {
                            const char = line[i];
                            if (char === '"') {
                                inQuotes = !inQuotes;
                            } else if (char === ',' && !inQuotes) {
                                result.push(current.trim());
                                current = '';
                            } else {
                                current += char;
                            }
                        }
                        result.push(current.trim());
                        return result;
                    });
                } else {
                    // Handle Excel files
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, {type: 'array'});
                    const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                    jsonData = XLSX.utils.sheet_to_json(firstSheet, {header: 1, defval: ''});
                }

                currentData = jsonData.filter(row => row.some(cell => cell !== ''));

                if (currentData.length > 0) {
                    // Enable the next button instead of auto-progressing
                    document.getElementById('uploadNextBtn').disabled = false;
                    showUploadMessage('‚úì File uploaded successfully! You can now optionally upload previous pricing data, or click Next to continue.', 'success');
                }
            };

            if (isCSV) {
                reader.readAsText(file);
            } else {
                reader.readAsArrayBuffer(file);
            }
        }

        function proceedFromUpload() {
            if (currentData.length > 0) {
                renderMappingTable();
                goToStep(3);
            }
        }

        function validateSettings() {
            // Get settings values
            settings.manufacturerName = document.getElementById('manufacturerName').value.trim();
            settings.supplierAccountNumber = document.getElementById('supplierAccountNumber').value.trim();
            settings.effectiveDate = document.getElementById('effectiveDate').value;

            // Validate required fields
            if (!settings.manufacturerName) {
                alert('Please enter the manufacturer or brand name');
                return;
            }

            if (!settings.supplierAccountNumber) {
                alert('Please enter the supplier account number');
                return;
            }

            if (!settings.effectiveDate) {
                alert('Please select the price list effective date');
                return;
            }

            // Proceed to upload step
            goToStep(2);
        }
        
        function handlePreviousFile(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                if (file.name.endsWith('.json')) {
                    previousData = JSON.parse(e.target.result);
                    showUploadMessage('‚úì Previous pricing data loaded successfully!', 'success', 'previousUploadMessages');
                } else {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, {type: 'array'});
                    const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                    const jsonData = XLSX.utils.sheet_to_json(firstSheet, {header: 1, defval: ''});

                    // Assume first row is headers, convert to objects
                    const headers = jsonData[0];
                    previousData = jsonData.slice(1).map(row => {
                        let obj = {};
                        headers.forEach((header, i) => {
                            obj[header.toLowerCase().replace(/\s+/g, '')] = row[i];
                        });
                        return obj;
                    });
                    showUploadMessage('‚úì Previous pricing data loaded successfully!', 'success', 'previousUploadMessages');
                }
            };
            
            if (file.name.endsWith('.json')) {
                reader.readAsText(file);
            } else {
                reader.readAsArrayBuffer(file);
            }
        }

        function showUploadMessage(message, type = 'success', targetDiv = 'uploadMessages') {
            const messagesDiv = document.getElementById(targetDiv);
            const messageClass = type === 'success' ? 'alert alert-info' : 'alert alert-warning';
            messagesDiv.innerHTML = `<div class="${messageClass}" style="animation: fadeIn 0.3s;">${message}</div>`;
        }

        function renderMappingTable() {
            // Step 2: Show only column headers and mapping dropdowns (no data editing)
            const table = document.getElementById('mappingTable');
            table.innerHTML = '';

            // Header row with column names
            const headerRow = document.createElement('tr');
            headerRow.innerHTML = '<th class="row-number">#</th>';
            currentData[0].forEach((cell, i) => {
                headerRow.innerHTML += `<th class="column-header-cell">
                    <span class="column-header-text">${cell || `Column ${String.fromCharCode(65 + i)}`}</span>
                </th>`;
            });
            table.appendChild(headerRow);

            // Mapping row with dropdowns
            const mappingRow = document.createElement('tr');
            mappingRow.innerHTML = '<th class="row-number" style="background: #e3f2fd;">Map to:</th>';

            const fieldOptions = [
                {value: '', label: '-- Ignore Column --'},
                {value: 'code', label: 'üì¶ Supplier Part Number *'},
                {value: 'description', label: 'üìù Description'},
                {value: 'costPrice', label: 'üí∞ Cost Price'},
                {value: 'listPrice', label: 'üí∑ List Price GBP'},
                {value: 'discount', label: 'üè∑Ô∏è Discount %'},
                {value: 'markup', label: 'üìà Markup %'},
                {value: 'barcode', label: 'üî¢ Barcode'},
                {value: 'manufacturer', label: 'üè≠ Manufacturer'},
                {value: 'countryOfOrigin', label: 'üåç Country of Origin'}
            ];

            currentData[0].forEach((header, colIndex) => {
                // No auto-detection - all columns default to "Ignore"
                mappingRow.innerHTML += `<th style="background: #e3f2fd; padding: 8px;">
                    <select id="colMap_${colIndex}" class="column-mapping-select" onchange="updateColumnMapping()">
                        ${fieldOptions.map(opt =>
                            `<option value="${opt.value}">${opt.label}</option>`
                        ).join('')}
                    </select>
                </th>`;
            });
            table.appendChild(mappingRow);

            // Show first 5 rows as preview
            for (let rowIndex = 1; rowIndex <= Math.min(5, currentData.length - 1); rowIndex++) {
                const row = currentData[rowIndex];
                const tr = document.createElement('tr');
                tr.innerHTML = `<td class="row-number">${rowIndex}</td>`;
                for (let colIndex = 0; colIndex < currentData[0].length; colIndex++) {
                    const cell = row[colIndex] || '';
                    tr.innerHTML += `<td style="color: #666;">${cell}</td>`;
                }
                table.appendChild(tr);
            }

            // Initialize mapping
            updateColumnMapping();
        }

        function validateMapping() {
            // Validate required mappings
            if (columnMapping.code === undefined) {
                alert('Please map the required field: Supplier Part Number');
                return;
            }

            // Need at least one price field
            if (columnMapping.listPrice === undefined && columnMapping.costPrice === undefined) {
                alert('Please map at least one price field: either List Price OR Cost Price');
                return;
            }

            // Prepare Step 4 with appropriate discount/markup column
            prepareStep3();
            goToStep(4);
        }

        function prepareStep3() {
            // Based on mapping, add discount % or markup % column if needed
            const hasListPrice = columnMapping.listPrice !== undefined;
            const hasCostPrice = columnMapping.costPrice !== undefined;

            let infoMessage = '';
            let addedColumn = false;

            if (hasListPrice && !hasCostPrice) {
                // Only have list price - add discount % column
                const columnName = 'Discount %';
                if (!currentData[0].includes(columnName)) {
                    currentData[0].push(columnName);
                    for (let i = 1; i < currentData.length; i++) {
                        currentData[i].push('');
                    }
                    addedColumn = true;
                }
                columnMapping.discount = currentData[0].indexOf(columnName);
                infoMessage = 'A <strong>Discount %</strong> column has been added. Enter discount percentages to calculate cost prices from list prices.';
            } else if (hasCostPrice && !hasListPrice) {
                // Only have cost price - add markup % column
                const columnName = 'Markup %';
                if (!currentData[0].includes(columnName)) {
                    currentData[0].push(columnName);
                    for (let i = 1; i < currentData.length; i++) {
                        currentData[i].push('');
                    }
                    addedColumn = true;
                }
                columnMapping.markup = currentData[0].indexOf(columnName);
                infoMessage = 'A <strong>Markup %</strong> column has been added. Enter markup percentages to calculate list prices from cost prices.';
            } else {
                // Have both prices
                infoMessage = 'You have both Cost Price and List Price columns. Edit your data as needed below.';
            }

            document.getElementById('step3Info').innerHTML = infoMessage;
        }

        function getMappedColumnIndices() {
            // Define the desired column order
            const columnOrder = ['code', 'description', 'costPrice', 'discount', 'listPrice', 'markup', 'barcode', 'manufacturer', 'countryOfOrigin'];

            const mappedIndices = [];

            // Add columns in the desired order
            columnOrder.forEach(fieldName => {
                if (columnMapping[fieldName] !== undefined) {
                    mappedIndices.push(columnMapping[fieldName]);
                }
            });

            return mappedIndices;
        }

        function findDuplicateCodes() {
            const duplicates = new Set();
            const codeCol = columnMapping.code;

            if (codeCol === undefined) return duplicates;

            const codeCounts = {};

            // Count occurrences of each code (case-insensitive, skip excluded rows)
            for (let rowIndex = 1; rowIndex < currentData.length; rowIndex++) {
                if (excludedRows.has(rowIndex)) continue;

                const code = currentData[rowIndex][codeCol];
                if (code) {
                    const normalizedCode = code.toString().toLowerCase();
                    codeCounts[normalizedCode] = (codeCounts[normalizedCode] || 0) + 1;
                }
            }

            // Find codes that appear more than once
            for (const [code, count] of Object.entries(codeCounts)) {
                if (count > 1) {
                    duplicates.add(code);
                }
            }

            return duplicates;
        }

        function renderSpreadsheet() {
            const table = document.getElementById('spreadsheet');
            table.innerHTML = '';

            // Get only mapped columns (ignore columns that are not mapped)
            const mappedIndices = getMappedColumnIndices();

            // Check if discount or markup columns are mapped
            const hasDiscount = columnMapping.discount !== undefined;
            const hasMarkup = columnMapping.markup !== undefined;

            // Show/hide quick tools based on mapping
            document.getElementById('discountToolsSection3').style.display = hasDiscount ? 'block' : 'none';
            document.getElementById('markupToolsSection3').style.display = hasMarkup ? 'block' : 'none';
            document.getElementById('step3Tools').style.display = (hasDiscount || hasMarkup) ? 'block' : 'none';

            // Find duplicate codes
            const duplicateCodes = findDuplicateCodes();

            // Header row with column names (only mapped columns)
            const headerRow = document.createElement('tr');
            headerRow.innerHTML = `<th class="row-number" style="text-align: center;">#</th><th>${settings.manufacturerName} - ${settings.supplierAccountNumber}</th>`;

            // Map field names to display names
            const fieldDisplayNames = {
                'code': 'Supplier Part Number',
                'description': 'Description',
                'costPrice': 'Cost Price',
                'discount': 'Discount %',
                'listPrice': 'List Price GBP',
                'markup': 'Markup %',
                'barcode': 'Barcode',
                'manufacturer': 'Manufacturer',
                'countryOfOrigin': 'Country of Origin'
            };

            mappedIndices.forEach(i => {
                // Find which field this column is mapped to
                const fieldName = Object.keys(columnMapping).find(key => columnMapping[key] === i);
                const displayName = fieldDisplayNames[fieldName] || currentData[0][i];

                const isDiscountCol = columnMapping.discount === i;
                const isMarkupCol = columnMapping.markup === i;
                const isFlexCol = isDiscountCol || isMarkupCol;
                headerRow.innerHTML += `<th class="column-header-cell" style="${isFlexCol ? 'background: #fff3cd;' : ''}">
                    <span class="column-header-text">${displayName}</span>
                </th>`;
            });
            table.appendChild(headerRow);

            // Data rows
            for (let rowIndex = 1; rowIndex < currentData.length; rowIndex++) {
                const row = currentData[rowIndex];
                const tr = document.createElement('tr');
                const isExcluded = excludedRows.has(rowIndex);
                tr.className = isExcluded ? 'excluded-row' : '';

                // Get the code to look up in previous data
                const code = columnMapping.code !== undefined ? row[columnMapping.code] : '';
                let previousDescription = '';
                let prevDescBg = '';

                if (code) {
                    // Check if this item exists in previous data (case-insensitive)
                    const oldItem = previousData.find(p =>
                        (p.code && p.code.toLowerCase() === code.toLowerCase()) ||
                        (p.productcode && p.productcode.toLowerCase() === code.toLowerCase())
                    );

                    if (oldItem) {
                        // Found in database
                        previousDescription = oldItem.description || '-';
                        prevDescBg = '#90EE90'; // Bright green
                    } else {
                        // New product
                        previousDescription = 'New product? Check if new';
                        prevDescBg = '#FFFF00'; // Bright yellow
                    }
                } else {
                    previousDescription = '-';
                }

                tr.innerHTML = `<td class="row-number" style="cursor: pointer; text-align: center;" onclick="toggleRowExclusion(${rowIndex})" title="${isExcluded ? 'Click to restore row' : 'Click to exclude row'}">
                    ${isExcluded ? '‚ùå' : rowIndex}
                </td><td style="background: ${prevDescBg};">${previousDescription}</td>`;

                mappedIndices.forEach(colIndex => {
                    const cell = row[colIndex] || '';
                    const isDiscountCol = columnMapping.discount === colIndex;
                    const isMarkupCol = columnMapping.markup === colIndex;
                    const isFlexCol = isDiscountCol || isMarkupCol;
                    const isCodeCol = columnMapping.code === colIndex;
                    const isDuplicate = isCodeCol && cell && duplicateCodes.has(cell.toString().toLowerCase());

                    let bgColor = '';
                    if (isDuplicate) {
                        bgColor = '#ffcccc'; // Red for duplicates
                    } else if (isFlexCol) {
                        bgColor = '#fff3cd';
                    }

                    const cellStyle = bgColor ? `background: ${bgColor};` : '';
                    const inputStyle = bgColor ? `background: ${bgColor};` : '';

                    tr.innerHTML += `<td style="${cellStyle}"><input type="text"
                        value="${cell}"
                        onchange="updateCell(${rowIndex}, ${colIndex}, this.value)"
                        onkeydown="handleKeyDown(event, ${rowIndex}, ${colIndex})"
                        onfocus="handleFocus(${rowIndex}, ${colIndex})"
                        style="${inputStyle}"
                        placeholder="${isFlexCol ? '0' : ''}"></td>`;
                });

                table.appendChild(tr);
            }
        }
        
        function updateColumnMapping() {
            columnMapping = {};
            
            currentData[0].forEach((header, colIndex) => {
                const select = document.getElementById(`colMap_${colIndex}`);
                if (select && select.value) {
                    columnMapping[select.value] = colIndex;
                }
            });
        }
        
        function renderColumnMapping() {
            // This function is no longer needed - mapping is in the table
        }
        
        function toggleRowSelection(rowIndex, event) {
            if (rowIndex === 0) return; // Don't select header
            
            if (event.ctrlKey || event.metaKey) {
                if (selectedRows.has(rowIndex)) {
                    selectedRows.delete(rowIndex);
                } else {
                    selectedRows.add(rowIndex);
                }
            } else {
                selectedRows.clear();
                selectedRows.add(rowIndex);
            }
            renderSpreadsheet();
        }
        
        function toggleAllRows() {
            if (selectedRows.size === currentData.length - 1) {
                selectedRows.clear();
            } else {
                selectedRows.clear();
                for (let i = 1; i < currentData.length; i++) {
                    selectedRows.add(i);
                }
            }
            renderSpreadsheet();
        }
        
        function handleKeyDown(event, row, col) {
            // Get the mapped discount column index
            const discountColIndex = columnMapping.discount;
            
            // Copy (Ctrl+C)
            if ((event.ctrlKey || event.metaKey) && event.key === 'c') {
                copiedValue = event.target.value;
                event.target.style.background = '#ffffcc';
                setTimeout(() => {
                    event.target.style.background = col === discountColIndex ? '#d4edda' : '';
                }, 200);
            }
            
            // Paste to single cell (Ctrl+V)
            if ((event.ctrlKey || event.metaKey) && event.key === 'v' && !event.shiftKey && copiedValue !== null) {
                event.preventDefault();
                event.target.value = copiedValue;
                updateCell(row, col, copiedValue);
            }
            
            // Paste to all selected rows (Ctrl+Shift+V) - only works for discount/markup columns
            if ((event.ctrlKey || event.metaKey) && event.shiftKey && event.key.toLowerCase() === 'v' && copiedValue !== null) {
                event.preventDefault();
                if (selectedRows.size === 0) {
                    alert('Please select rows first (Ctrl+click row numbers)');
                    return;
                }

                // Determine which column to paste to based on current cell
                let targetColIndex = discountColIndex;
                if (columnMapping.markup === col) {
                    targetColIndex = columnMapping.markup;
                }

                if (targetColIndex === undefined) {
                    alert('Bulk paste only works for Discount % or Markup % columns');
                    return;
                }

                selectedRows.forEach(rowIndex => {
                    if (rowIndex > 0) { // Skip header
                        // Ensure row has enough columns
                        while (currentData[rowIndex].length <= targetColIndex) {
                            currentData[rowIndex].push('');
                        }
                        currentData[rowIndex][targetColIndex] = copiedValue;
                    }
                });

                renderSpreadsheet();
                alert(`Pasted "${copiedValue}" to ${selectedRows.size} selected rows`);
            }
            
            // Arrow key navigation
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Enter'].includes(event.key)) {
                event.preventDefault();
                let newRow = row;
                let newCol = col;
                
                if (event.key === 'ArrowUp') newRow = Math.max(1, row - 1);
                if (event.key === 'ArrowDown' || event.key === 'Enter') newRow = Math.min(currentData.length - 1, row + 1);
                if (event.key === 'ArrowLeft') newCol = Math.max(0, col - 1);
                if (event.key === 'ArrowRight') newCol = Math.min(currentData[0].length - 1, col + 1);
                
                const table = document.getElementById('spreadsheet');
                const targetInput = table.rows[newRow].cells[newCol + 1].querySelector('input');
                if (targetInput && !targetInput.readOnly) {
                    targetInput.focus();
                    targetInput.select();
                }
            }
        }
        
        function handleFocus(row, col) {
            // Auto-select text for easy overwriting
            event.target.select();
        }
        
        function applyBulkDiscount() {
            const discount = document.getElementById('bulkDiscount3').value;
            if (!discount) {
                alert('Please enter a discount percentage');
                return;
            }

            // Get the mapped discount column index
            const discountColIndex = columnMapping.discount;
            if (discountColIndex === undefined) {
                alert('Error: No column is mapped to Discount %. Please map a column first.');
                return;
            }

            for (let i = 1; i < currentData.length; i++) {
                // Ensure row has enough columns
                while (currentData[i].length <= discountColIndex) {
                    currentData[i].push('');
                }
                currentData[i][discountColIndex] = discount;
            }
            renderSpreadsheet();
            alert(`Applied ${discount}% discount to all ${currentData.length - 1} rows`);
        }

        function applyDiscountToSelected() {
            const discount = document.getElementById('bulkDiscount3').value;
            if (!discount) {
                alert('Please enter a discount percentage');
                return;
            }

            if (selectedRows.size === 0) {
                alert('Please select rows first by clicking the row numbers (hold Ctrl to select multiple)');
                return;
            }

            // Get the mapped discount column index
            const discountColIndex = columnMapping.discount;
            if (discountColIndex === undefined) {
                alert('Error: No column is mapped to Discount %. Please map a column first.');
                return;
            }

            selectedRows.forEach(rowIndex => {
                // Ensure row has enough columns
                while (currentData[rowIndex].length <= discountColIndex) {
                    currentData[rowIndex].push('');
                }
                currentData[rowIndex][discountColIndex] = discount;
            });

            renderSpreadsheet();
            alert(`Applied ${discount}% discount to ${selectedRows.size} selected rows`);
        }

        function clearAllDiscounts() {
            if (!confirm('Clear all discount values?')) return;

            const discountColIndex = columnMapping.discount;
            if (discountColIndex === undefined) return;

            for (let i = 1; i < currentData.length; i++) {
                if (currentData[i][discountColIndex] !== undefined) {
                    currentData[i][discountColIndex] = '';
                }
            }
            renderSpreadsheet();
        }
        
        function clearSelectedDiscounts() {
            if (selectedRows.size === 0) {
                alert('Please select rows first by clicking the row numbers');
                return;
            }

            if (!confirm(`Clear discount values for ${selectedRows.size} selected rows?`)) return;

            const discountColIndex = columnMapping.discount;
            if (discountColIndex === undefined) return;

            selectedRows.forEach(rowIndex => {
                if (currentData[rowIndex][discountColIndex] !== undefined) {
                    currentData[rowIndex][discountColIndex] = '';
                }
            });
            renderSpreadsheet();
        }

        function applyMarkupToSelected() {
            const markup = document.getElementById('bulkMarkup3').value;
            if (!markup) {
                alert('Please enter a markup percentage');
                return;
            }

            if (selectedRows.size === 0) {
                alert('Please select rows first by clicking row numbers (hold Ctrl to select multiple)');
                return;
            }

            const markupColIndex = columnMapping.markup;

            if (markupColIndex === undefined) {
                alert('Error: No column is mapped to Markup %. Please map a column first.');
                return;
            }

            selectedRows.forEach(rowIndex => {
                while (currentData[rowIndex].length <= markupColIndex) {
                    currentData[rowIndex].push('');
                }
                currentData[rowIndex][markupColIndex] = markup;
            });

            renderSpreadsheet();
            alert(`Applied ${markup}% markup to ${selectedRows.size} selected rows`);
        }

        function applyBulkMarkup() {
            const markup = document.getElementById('bulkMarkup3').value;
            if (!markup) {
                alert('Please enter a markup percentage');
                return;
            }

            const markupColIndex = columnMapping.markup;

            if (markupColIndex === undefined) {
                alert('Error: No column is mapped to Markup %. Please map a column first.');
                return;
            }

            for (let i = 1; i < currentData.length; i++) {
                while (currentData[i].length <= markupColIndex) {
                    currentData[i].push('');
                }
                currentData[i][markupColIndex] = markup;
            }
            renderSpreadsheet();
            alert(`Applied ${markup}% markup to all ${currentData.length - 1} rows`);
        }

        function clearSelectedMarkups() {
            if (selectedRows.size === 0) {
                alert('Please select rows first by clicking row numbers');
                return;
            }

            if (!confirm(`Clear markup values for ${selectedRows.size} selected rows?`)) return;

            const markupColIndex = columnMapping.markup;
            if (markupColIndex === undefined) return;

            selectedRows.forEach(rowIndex => {
                if (currentData[rowIndex][markupColIndex] !== undefined) {
                    currentData[rowIndex][markupColIndex] = '';
                }
            });
            renderSpreadsheet();
        }

        function clearAllMarkups() {
            if (!confirm('Clear all markup values?')) return;

            const markupColIndex = columnMapping.markup;
            if (markupColIndex === undefined) return;

            for (let i = 1; i < currentData.length; i++) {
                if (currentData[i][markupColIndex] !== undefined) {
                    currentData[i][markupColIndex] = '';
                }
            }
            renderSpreadsheet();
        }
        
        function updateCell(row, col, value) {
            currentData[row][col] = value;
            // Re-render if code column was edited to update duplicate highlighting
            if (columnMapping.code === col) {
                renderSpreadsheet();
            }
        }
        
        function deleteColumn(colIndex) {
            const colName = currentData[0][colIndex];
            if (!confirm(`Delete the "${colName}" column and all its data?`)) return;
            
            // Remove column from all rows
            for (let i = 0; i < currentData.length; i++) {
                currentData[i].splice(colIndex, 1);
            }
            
            // Clear the mapping for this column
            updateColumnMapping();
            renderSpreadsheet();
            alert(`"${colName}" column deleted`);
        }
        
        function toggleRowExclusion(rowIndex) {
            if (excludedRows.has(rowIndex)) {
                excludedRows.delete(rowIndex);
            } else {
                excludedRows.add(rowIndex);
            }
            renderSpreadsheet();
        }

        function deleteRow(rowIndex) {
            // Deprecated - keeping for backward compatibility
            toggleRowExclusion(rowIndex);
        }
        
        function goToStep(step) {
            document.querySelectorAll('.step').forEach(s => s.classList.remove('active'));
            document.getElementById(`step${step}`).classList.add('active');
            currentStep = step;

            if (step === 4) {
                renderSpreadsheet();
            } else if (step === 5) {
                renderPreviewOnly();
            } else if (step === 6) {
                renderOriginalPriceList();
            }
        }
        
        function renderPreviewOnly() {
            const table = document.getElementById('previewTable');
            const hasDiscount = columnMapping.discount !== undefined;
            const hasMarkup = columnMapping.markup !== undefined;
            const hasBothPrices = columnMapping.listPrice !== undefined && columnMapping.costPrice !== undefined;

            table.innerHTML = `
                <thead>
                    <tr>
                        <th>Code</th>
                        <th>Description</th>
                        ${hasBothPrices ? '<th>Cost Price</th>' : ''}
                        ${hasBothPrices ? '<th>List Price</th>' : ''}
                        ${!hasBothPrices ? `<th>${hasDiscount ? 'List Price' : 'Cost Price'}</th>` : ''}
                        ${hasDiscount ? '<th>Discount %</th>' : ''}
                        ${hasMarkup ? '<th>Markup %</th>' : ''}
                        ${!hasBothPrices ? `<th>Calculated ${hasDiscount ? 'Cost Price' : 'List Price'}</th>` : ''}
                        <th>Manufacturer</th>
                        <th>Country</th>
                        <th>Barcode</th>
                    </tr>
                </thead>
                <tbody>
            `;

            // Filter out excluded rows, then take first 10 non-excluded rows
            const previewRows = currentData.slice(1)
                .filter((row, index) => !excludedRows.has(index + 1))
                .slice(0, 10);
            previewRows.forEach(row => {
                const listPrice = columnMapping.listPrice !== undefined ? parseFloat(row[columnMapping.listPrice]) || 0 : 0;
                const discount = columnMapping.discount !== undefined ? parseFloat(row[columnMapping.discount]) || 0 : 0;
                const markup = columnMapping.markup !== undefined ? parseFloat(row[columnMapping.markup]) || 0 : 0;
                const costPrice = columnMapping.costPrice !== undefined ? parseFloat(row[columnMapping.costPrice]) || 0 : 0;

                let calculatedValue = 0;
                if (hasDiscount) {
                    calculatedValue = costPrice > 0 ? costPrice : listPrice * (1 - discount / 100);
                } else if (hasMarkup) {
                    calculatedValue = listPrice > 0 ? listPrice : costPrice * (1 + markup / 100);
                }

                table.innerHTML += `
                    <tr>
                        <td>${columnMapping.code !== undefined ? row[columnMapping.code] : '-'}</td>
                        <td>${columnMapping.description !== undefined ? row[columnMapping.description] : '-'}</td>
                        ${hasBothPrices ? `<td>${costPrice > 0 ? '¬£' + costPrice.toFixed(2) : '-'}</td>` : ''}
                        ${hasBothPrices ? `<td>${listPrice > 0 ? '¬£' + listPrice.toFixed(2) : '-'}</td>` : ''}
                        ${!hasBothPrices ? `<td>${hasDiscount ?
                            (listPrice > 0 ? '¬£' + listPrice.toFixed(2) : '-') :
                            (costPrice > 0 ? '¬£' + costPrice.toFixed(2) : '-')}</td>` : ''}
                        ${hasDiscount ? `<td>${discount > 0 ? discount.toFixed(1) + '%' : '-'}</td>` : ''}
                        ${hasMarkup ? `<td>${markup > 0 ? markup.toFixed(1) + '%' : '-'}</td>` : ''}
                        ${!hasBothPrices ? `<td style="background: #e8f5e9;">${calculatedValue > 0 ? '¬£' + calculatedValue.toFixed(2) : '-'}</td>` : ''}
                        <td>${columnMapping.manufacturer !== undefined ? row[columnMapping.manufacturer] : '-'}</td>
                        <td>${columnMapping.countryOfOrigin !== undefined ? row[columnMapping.countryOfOrigin] : '-'}</td>
                        <td>${columnMapping.barcode !== undefined ? row[columnMapping.barcode] : '-'}</td>
                    </tr>
                `;
            });

            table.innerHTML += '</tbody>';
        }

        function findDuplicateVariantCodes() {
            const duplicates = new Set();
            const codeCounts = {};

            // Count occurrences of each variant code (case-insensitive, skip excluded rows)
            currentData.slice(1).forEach((row, index) => {
                const rowIndex = index + 1;
                if (excludedRows.has(rowIndex)) return;

                const code = columnMapping.code !== undefined ? row[columnMapping.code] : '';
                if (code) {
                    const normalizedCode = code.toString().toLowerCase();
                    codeCounts[normalizedCode] = (codeCounts[normalizedCode] || 0) + 1;
                }
            });

            // Find codes that appear more than once
            for (const [code, count] of Object.entries(codeCounts)) {
                if (count > 1) {
                    duplicates.add(code);
                }
            }

            return duplicates;
        }

        function renderOriginalPriceList() {
            const table = document.getElementById('originalPriceTable');
            const hasDiscount = columnMapping.discount !== undefined;
            const hasMarkup = columnMapping.markup !== undefined;

            // Find duplicate variant codes
            const duplicateVariantCodes = findDuplicateVariantCodes();

            table.innerHTML = `
                <thead>
                    <tr>
                        <th>#</th>
                        <th>Manufacturer</th>
                        <th>Variant Code</th>
                        <th>Description</th>
                        <th style="text-align: center;">üî¢</th>
                        <th>Name would like to use</th>
                        <th>Previous Description</th>
                        <th style="text-align: center;">üî¢</th>
                        <th>Description to use</th>
                        <th>Cost Price</th>
                        <th>List Price</th>
                        <th>Barcode</th>
                        <th>Previous Barcode</th>
                    </tr>
                </thead>
                <tbody>
            `;

            // Process rows (skip excluded rows)
            let lineNumber = 1;
            currentData.slice(1).forEach((row, index) => {
                const rowIndex = index + 1;
                if (excludedRows.has(rowIndex)) {
                    return; // Skip excluded rows
                }

                const code = columnMapping.code !== undefined ? row[columnMapping.code] : '';
                const description = columnMapping.description !== undefined ? row[columnMapping.description] : '';
                const barcode = columnMapping.barcode !== undefined ? row[columnMapping.barcode] : '';
                const manufacturer = columnMapping.manufacturer !== undefined ? row[columnMapping.manufacturer] : settings.manufacturerName;

                // Calculate prices
                const listPrice = columnMapping.listPrice !== undefined ? parseFloat(row[columnMapping.listPrice]) || 0 : 0;
                const discount = hasDiscount ? parseFloat(row[columnMapping.discount]) || 0 : 0;
                const markup = hasMarkup ? parseFloat(row[columnMapping.markup]) || 0 : 0;
                const directCostPrice = columnMapping.costPrice !== undefined ? parseFloat(row[columnMapping.costPrice]) || 0 : 0;

                let costPrice = directCostPrice;
                let finalListPrice = listPrice;

                if (hasDiscount) {
                    if (directCostPrice > 0) {
                        costPrice = directCostPrice;
                    } else if (listPrice > 0 && discount > 0) {
                        costPrice = listPrice * (1 - discount / 100);
                    }
                } else if (hasMarkup) {
                    if (listPrice > 0) {
                        finalListPrice = listPrice;
                    } else if (directCostPrice > 0 && markup > 0) {
                        finalListPrice = directCostPrice * (1 + markup / 100);
                    }
                    costPrice = directCostPrice;
                }

                // Name would like to use: MANUFACTURER ( CODE ) DESCRIPTION
                const nameWouldLike = `${manufacturer} ( ${code} ) ${description}`;

                // Check if this item exists in previous data (case-insensitive)
                const oldItem = previousData.find(p =>
                    (p.code && p.code.toLowerCase() === code.toLowerCase()) ||
                    (p.productcode && p.productcode.toLowerCase() === code.toLowerCase())
                );

                let previousDescription = '';
                let previousBarcode = '';
                let descriptionToUse = '';

                if (oldItem) {
                    // Found in database
                    previousDescription = oldItem.description || '-';
                    previousBarcode = oldItem.barcode || '-';
                    descriptionToUse = previousDescription; // Default to previous description
                } else {
                    // New product
                    previousDescription = 'New product? Check if new';
                    previousBarcode = '-';
                    descriptionToUse = nameWouldLike; // Use the formatted name
                }

                // Set default "Description to use" value only if not already set by user
                if (!descriptionToUseMap[code]) {
                    descriptionToUseMap[code] = descriptionToUse;
                }

                // Calculate character counts
                const nameCharCount = nameWouldLike.length;
                const descCharCount = descriptionToUseMap[code].length;

                // Style for "Name would like to use" character count
                let nameCharStyle = '';
                if (nameCharCount > 250) {
                    nameCharStyle = 'color: red; font-weight: bold;';
                } else if (nameCharCount >= descCharCount * 1.1) {
                    nameCharStyle = 'color: limegreen; font-weight: bold;';
                }

                // Style for "Description to use" character count
                const descCharStyle = descCharCount > 250 ? 'color: red; font-weight: bold;' : '';

                // Escape values for JavaScript strings
                const escapedCode = code.replace(/'/g, "\\'").replace(/"/g, '\\"');
                const escapedNameWouldLike = nameWouldLike.replace(/'/g, "\\'").replace(/"/g, '\\"');
                const escapedPreviousDesc = previousDescription.replace(/'/g, "\\'").replace(/"/g, '\\"');

                // Check if "Name would like to use" or "Previous Description" matches "Description to use"
                const nameMatchesDesc = nameWouldLike === descriptionToUseMap[code];
                const prevMatchesDesc = previousDescription === descriptionToUseMap[code];
                const nameTextColor = nameMatchesDesc ? 'color: #999;' : '';
                const prevTextColor = prevMatchesDesc ? 'color: #999;' : '';

                // Check if this is a new product
                const isNewProduct = previousDescription === 'New product? Check if new';
                const yellowBg = '#ffe082';
                const redBg = '#ffcccc';

                // Check if this variant code is a duplicate
                const isDuplicateCode = duplicateVariantCodes.has(code.toLowerCase());

                // Set backgrounds based on whether it's a new product or duplicate
                const manufacturerBg = isNewProduct ? yellowBg : '#ffffe0';
                const codeBg = isDuplicateCode ? redBg : (isNewProduct ? yellowBg : '#ffffe0');
                const codeInputBg = isDuplicateCode ? redBg : 'transparent';
                const descriptionBg = isNewProduct ? yellowBg : '#ffffe0';
                const nameWouldLikeBg = isNewProduct ? yellowBg : '#ffe0f0';
                const prevDescBg = isNewProduct ? yellowBg : '#ffe5cc';
                const descToUseBg = isNewProduct ? yellowBg : '#ccffcc';
                const costListBg = isNewProduct ? `background: ${yellowBg};` : '';
                const barcodeBg = isNewProduct ? `background: ${yellowBg};` : '';

                table.innerHTML += `
                    <tr>
                        <td style="background: #00ff00; text-align: center;">${lineNumber}</td>
                        <td style="background: ${manufacturerBg};">${manufacturer}</td>
                        <td style="background: ${codeBg}; padding: 0;">
                            <input type="text"
                                   id="codeInput_${rowIndex}"
                                   value="${code}"
                                   onchange="updateVariantCode(${rowIndex}, this.value)"
                                   style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 0; background: ${codeInputBg}; box-sizing: border-box;">
                        </td>
                        <td style="background: ${descriptionBg};">${description}</td>
                        <td style="text-align: center; ${nameCharStyle} ${isNewProduct ? 'background: ' + yellowBg + ';' : ''}">${nameCharCount}</td>
                        <td style="cursor: pointer; background: ${nameWouldLikeBg}; ${nameTextColor}"
                            onclick="setDescriptionToUse('${escapedCode}', '${escapedNameWouldLike}')"
                            title="Click to use this as Description to use">${nameWouldLike}</td>
                        <td style="${isNewProduct ? '' : 'cursor: pointer;'} background: ${prevDescBg}; ${prevTextColor}"
                            ${isNewProduct ? '' : `onclick="setDescriptionToUse('${escapedCode}', '${escapedPreviousDesc}')"`}
                            ${isNewProduct ? '' : 'title="Click to use this as Description to use"'}>${previousDescription}</td>
                        <td id="charCount_${code}" style="text-align: center; ${descCharStyle} ${isNewProduct ? 'background: ' + yellowBg + ';' : ''}">${descCharCount}</td>
                        <td style="background: ${descToUseBg}; padding: 0;">
                            <input type="text"
                                   id="descInput_${code}"
                                   value="${descriptionToUseMap[code]}"
                                   onchange="updateDescriptionToUse('${escapedCode}', this.value)"
                                   oninput="updateCharCount('${escapedCode}')"
                                   style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 0; background: transparent; box-sizing: border-box;">
                        </td>
                        <td style="${costListBg}">¬£${costPrice.toFixed(2)}</td>
                        <td style="${costListBg}">¬£${finalListPrice.toFixed(2)}</td>
                        <td style="${barcodeBg}">${barcode || '-'}</td>
                        <td style="${barcodeBg}">${previousBarcode}</td>
                    </tr>
                `;

                lineNumber++;
            });

            table.innerHTML += '</tbody>';
        }

        function updateDescriptionToUse(code, value) {
            descriptionToUseMap[code] = value;
            // Re-render the table to update grey-out styling
            renderOriginalPriceList();
        }

        function updateVariantCode(rowIndex, value) {
            // Get the original code for this row to clear its description
            const originalCode = columnMapping.code !== undefined ? currentData[rowIndex][columnMapping.code] : '';
            if (originalCode) {
                delete descriptionToUseMap[originalCode];
            }

            // Update the currentData array directly
            if (columnMapping.code !== undefined) {
                currentData[rowIndex][columnMapping.code] = value;
            }

            // Re-render the table to update Name, Previous Description, and Description to use
            renderOriginalPriceList();
        }

        function setDescriptionToUse(code, value) {
            // Update the map
            descriptionToUseMap[code] = value;

            // Re-render the entire table to update styling
            renderOriginalPriceList();
        }

        function updateCharCount(code) {
            const input = document.getElementById(`descInput_${code}`);
            const charCountCell = document.getElementById(`charCount_${code}`);

            if (input && charCountCell) {
                const count = input.value.length;
                charCountCell.textContent = count;

                // Update styling based on character count (always keep text-align: center)
                charCountCell.style.textAlign = 'center';
                if (count > 250) {
                    charCountCell.style.color = 'red';
                    charCountCell.style.fontWeight = 'bold';
                } else {
                    charCountCell.style.color = '';
                    charCountCell.style.fontWeight = '';
                }
            }
        }

        function renderSpreadsheetStep3() {
            // This function is no longer needed - removed Step 3 spreadsheet
        }
        
        function renderMapping() {
            // This function is no longer needed since mapping is done in step 2
        }
        
        function updateMapping() {
            // This function is no longer needed since we use updateColumnMapping
        }
        
        function renderPreview() {
            // This function is no longer needed since preview is in step 3
        }
        
        function processData() {
            // Mapping is already validated in validateAndProcess
            
            const hasDiscount = columnMapping.discount !== undefined;
            const hasMarkup = columnMapping.markup !== undefined;

            // Convert data to objects (skip excluded rows)
            processedData = currentData.slice(1).map((row, index) => {
                const rowIndex = index + 1; // Adjust for header row
                if (excludedRows.has(rowIndex)) {
                    return null; // Mark for filtering
                }
                return { row, rowIndex }; // Keep rowIndex with the row
            }).filter(item => item !== null).map(({ row, rowIndex }) => {
                const listPrice = columnMapping.listPrice !== undefined ? parseFloat(row[columnMapping.listPrice]) || 0 : 0;
                const discount = hasDiscount ? parseFloat(row[columnMapping.discount]) || 0 : 0;
                const markup = hasMarkup ? parseFloat(row[columnMapping.markup]) || 0 : 0;
                const directCostPrice = columnMapping.costPrice !== undefined ? parseFloat(row[columnMapping.costPrice]) || 0 : 0;
                
                let costPrice = directCostPrice;
                let finalListPrice = listPrice;
                let calculatedFrom = '';
                
                if (hasDiscount) {
                    // Using discount: calculate cost from list price
                    if (directCostPrice > 0) {
                        costPrice = directCostPrice;
                    } else if (listPrice > 0 && discount > 0) {
                        costPrice = listPrice * (1 - discount / 100);
                        calculatedFrom = 'discount';
                    }
                } else if (hasMarkup) {
                    // Using markup: calculate list price from cost
                    if (listPrice > 0) {
                        finalListPrice = listPrice;
                    } else if (directCostPrice > 0 && markup > 0) {
                        finalListPrice = directCostPrice * (1 + markup / 100);
                        calculatedFrom = 'markup';
                    }
                    costPrice = directCostPrice;
                }
                
                const code = row[columnMapping.code];
                const item = {
                    code: code,
                    description: descriptionToUseMap[code] || (columnMapping.description !== undefined ? row[columnMapping.description] : ''),
                    costPrice: costPrice,
                    listPrice: finalListPrice,
                    discount: discount,
                    markup: markup,
                    manufacturer: columnMapping.manufacturer !== undefined ? row[columnMapping.manufacturer] : '',
                    countryOfOrigin: columnMapping.countryOfOrigin !== undefined ? row[columnMapping.countryOfOrigin] : '',
                    calculatedFrom: calculatedFrom,
                    barcode: columnMapping.barcode !== undefined ? row[columnMapping.barcode] : ''
                };

                // Compare with previous data (case-insensitive)
                const oldItem = previousData.find(p =>
                    (p.code && p.code.toLowerCase() === item.code.toLowerCase()) ||
                    (p.productcode && p.productcode.toLowerCase() === item.code.toLowerCase())
                );
                
                if (oldItem) {
                    const oldCost = parseFloat(oldItem.costPrice || oldItem.costprice || 0);
                    const oldList = parseFloat(oldItem.listPrice || oldItem.listprice || 0);
                    
                    item.costChange = oldCost > 0 ? ((item.costPrice - oldCost) / oldCost) * 100 : 0;
                    item.listChange = oldList > 0 ? ((item.listPrice - oldList) / oldList) * 100 : 0;
                    item.oldCostPrice = oldCost;
                    item.oldListPrice = oldList;
                    item.status = 'changed';
                    
                    // Flag if significant change
                    item.flagged = (
                        (item.costChange >= 15 || item.costChange <= -10) && item.costPrice >= 100
                    ) || (
                        (item.listChange >= 15 || item.listChange <= -10) && item.listPrice >= 100
                    );
                } else {
                    item.status = 'new';
                    item.flagged = false;
                }
                
                return item;
            }).filter(item => item.code); // Remove empty rows

            renderResults();
            goToStep(7);
        }
        
        function renderResults() {
            // Stats
            const total = processedData.length;
            const newItems = processedData.filter(i => i.status === 'new').length;
            const changed = processedData.filter(i => i.status === 'changed').length;
            const flagged = processedData.filter(i => i.flagged).length;
            
            const statsGrid = document.getElementById('statsGrid');
            statsGrid.innerHTML = `
                <div class="stat-card">
                    <div class="stat-number">${total}</div>
                    <div class="stat-label">Total Items</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${newItems}</div>
                    <div class="stat-label">New Items</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${changed}</div>
                    <div class="stat-label">Changed Items</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" style="color: #dc3545;">${flagged}</div>
                    <div class="stat-label">Flagged Items</div>
                </div>
            `;
            
            if (flagged > 0) {
                document.getElementById('flaggedAlert').style.display = 'block';
            }
            
            // Comparison table
            renderComparisonTable(processedData);
        }
        
        function findDuplicateCodesInProcessedData(data) {
            const duplicates = new Set();
            const codeCounts = {};

            // Count occurrences of each code (case-insensitive)
            data.forEach(item => {
                if (item.code) {
                    const normalizedCode = item.code.toString().toLowerCase();
                    codeCounts[normalizedCode] = (codeCounts[normalizedCode] || 0) + 1;
                }
            });

            // Find codes that appear more than once
            for (const [code, count] of Object.entries(codeCounts)) {
                if (count > 1) {
                    duplicates.add(code);
                }
            }

            return duplicates;
        }

        function renderComparisonTable(data) {
            const table = document.getElementById('comparisonTable');

            // Find duplicate codes in the data
            const duplicateCodes = findDuplicateCodesInProcessedData(data);

            table.innerHTML = `
                <thead>
                    <tr>
                        <th>Code</th>
                        <th>Description</th>
                        <th>Cost Price</th>
                        <th>List Price</th>
                        <th>Cost Change</th>
                        <th>Status</th>
                    </tr>
                </thead>
                <tbody>
            `;

            data.forEach(item => {
                const costChangeClass = item.costChange > 0 ? 'change-positive' : item.costChange < 0 ? 'change-negative' : '';

                const statusBadge = item.status === 'new' ?
                    '<span class="badge badge-info">NEW</span>' :
                    item.flagged ? '<span class="badge badge-warning">FLAGGED</span>' :
                    '<span class="badge badge-success">OK</span>';

                const costPriceDisplay = item.calculatedFrom === 'discount' ?
                    `¬£${item.costPrice.toFixed(2)} <small>(calc from discount)</small>` :
                    `¬£${item.costPrice.toFixed(2)}`;

                const listPriceDisplay = item.calculatedFrom === 'markup' ?
                    `¬£${item.listPrice.toFixed(2)} <small>(calc from markup)</small>` :
                    `¬£${item.listPrice.toFixed(2)}`;

                const rowClass = item.status === 'new' ? 'new-product' : (item.flagged ? 'flagged' : '');
                const isDuplicate = item.code && duplicateCodes.has(item.code.toString().toLowerCase());
                const codeStyle = isDuplicate ? 'background: #ffcccc;' : '';

                table.innerHTML += `
                    <tr class="${rowClass}">
                        <td style="${codeStyle}">${item.code}</td>
                        <td>${item.description}</td>
                        <td>${costPriceDisplay}</td>
                        <td>${listPriceDisplay}</td>
                        <td class="${costChangeClass}">
                            ${item.status === 'new' ? '-' :
                              `${item.costChange > 0 ? '+' : ''}${item.costChange.toFixed(1)}%<br>
                               <small>(was ¬£${item.oldCostPrice.toFixed(2)})</small>`}
                        </td>
                        <td>${statusBadge}</td>
                    </tr>
                `;
            });

            table.innerHTML += '</tbody>';
        }
        
        function toggleFilter() {
            const showOnlyFlaggedCheckbox = document.getElementById('showOnlyFlagged');
            const showOnlyNewCheckbox = document.getElementById('showOnlyNew');
            const showOnlyFlagged = showOnlyFlaggedCheckbox.checked;
            const showOnlyNew = showOnlyNewCheckbox.checked;

            // Make checkboxes mutually exclusive
            if (showOnlyFlagged && showOnlyNew) {
                // If both are checked, determine which one was just checked and uncheck the other
                // We'll use a data attribute to track which was last clicked
                const lastClicked = event.target.id;
                if (lastClicked === 'showOnlyFlagged') {
                    showOnlyNewCheckbox.checked = false;
                } else {
                    showOnlyFlaggedCheckbox.checked = false;
                }
            }

            let dataToShow = processedData;

            if (showOnlyFlaggedCheckbox.checked) {
                // Show only flagged items
                dataToShow = processedData.filter(i => i.flagged);
            } else if (showOnlyNewCheckbox.checked) {
                // Show only new items
                dataToShow = processedData.filter(i => i.status === 'new');
            }

            renderComparisonTable(dataToShow);
        }

        // Keep old function name for backwards compatibility
        function toggleFlaggedFilter() {
            toggleFilter();
        }
        
        function exportJSON() {
            const json = JSON.stringify(processedData, null, 2);
            const blob = new Blob([json], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `pricing_data_${new Date().toISOString().split('T')[0]}.json`;
            a.click();
        }
        
        function exportCSV() {
            let csv = 'Code,Description,List Price,Discount %,Cost Price,Calculated,Cost Change %,Status,Flagged\n';
            
            processedData.forEach(item => {
                csv += `"${item.code}","${item.description}",${item.listPrice},`;
                csv += `${item.discount},${item.costPrice},`;
                csv += `${item.calculatedFromDiscount ? 'YES' : 'NO'},`;
                csv += `${item.status === 'new' ? '' : item.costChange.toFixed(2)},`;
                csv += `${item.status},${item.flagged ? 'YES' : 'NO'}\n`;
            });
            
            const blob = new Blob([csv], {type: 'text/csv'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `pricing_export_${new Date().toISOString().split('T')[0]}.csv`;
            a.click();
        }
        
        function saveData() {
            // This would send data to your PHP backend
            const dataToSave = {
                importDate: new Date().toISOString(),
                totalItems: processedData.length,
                flaggedItems: processedData.filter(i => i.flagged).length,
                items: processedData
            };
            
            // Mock API call - replace with your actual endpoint
            console.log('Data to save:', dataToSave);
            
            alert('Save functionality would send this data to your PHP backend.\n\nEndpoint: POST /api/pricing/save\n\nCheck console for data structure.');
            
            /* Uncomment when you have your PHP endpoint ready:
            fetch('/api/pricing/save', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(dataToSave)
            })
            .then(response => response.json())
            .then(data => {
                alert('Data saved successfully!');
            })
            .catch(error => {
                alert('Error saving data: ' + error);
            });
            */
        }
    </script>
</body>
</html>